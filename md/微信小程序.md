# 微信小程序
## 1. 基础
### 1.WXML
#### 1. WXML 标签
```javascript{.line-numbers}
<view></view>
<text></text>
<button></button>
<image></image>
<navigator></navigator>
    1. url：表示要跳转的页面的地址，必须以 '/' 开头；
        传参：
            1. 路径与参数之间使用 '?' 分割；
            2. 参数键与参数值使用 '=' 分割；
            3. 不用参数使用 '&' 分割；
            4. 在 JS onLoad 事件中直接获取；
    2. open-type：表示跳转的方式
        1. 如果跳转 tabBar 页面，必须配置 switchTab；
        2. 如果跳转 非tabBar 页面，配置 navigate； 可以省略；
        3. 如果后退到上一级或者更多级，必须配置 navigateBlack
    3. delta：后退的层级，值必须为数字，默认值为 1；
<swiper>
    <swiper-item></swiper-item>    
</swiper>
```
#### 2. WXML 模板语法 (mustache 语法)
```javascript{.line-numbers}
   // 1. 在 .js 文件中 data 放置数据
   // 2. 在 .WXML 文件中使用数据
    // 2.1 渲染数据
    <view>{{info}}</view>
    // 2.2 动态绑定属性
    <image src="{{imgSrc}}"></image>
    // 2.3 三元表达式
    <view>{{num > 1? "大于1" : "小于1"}}</view>
```
#### 3. 事件绑定
```javascript{.line-numbers}
    // 1. wxml中事件绑定方法
    <button bindtap="bindTapHandle"></button>
    // js 中声明函数
    bindTapHandle(e){console.log(e)};
    // 2. 事件传参 通过 data-* 的方式
    <button bindtap="bindTapHandle" data-info="{{2}}"></button>
    // js 中接受参数 通过 e.target.dataset
    bindTapHandle(e){console.log(e.target.dataset.info)};
    // 3. bindinput
    <button bindinput="bindInputHandle"></button>
    // js 中获取 input 值
    bindInputHandle(e){console.log(e.detail.value)};
```
1. tap： 
    bindtap或bind:tap：手指触摸后马上离开，类似于HTML中的点击事件；
2. input：
    bindinput或bind:input：文本框的输入事件；
3. change：
    bindchange或bind:change：状态变化是触发；

#### 4. 条件渲染
```javascript{.line-numbers}
    <view wx:if="{{ type == 1 }}">男</view> 
    <view wx:elif="{{ type == 2 }}">女</view>
    <view wx:else>保密</view>
    
    <view hidden="{{true}}">
        hidden 为 true，就隐藏元素
        hidden 为 false，就显示元素
    </view>

    PS： wx：if 与 hidden 对比
        1. 运行方式的不同
            wx：if： 是动态创建或移除元素的方式
            hidden： 是通过控制样式的方式（display：none\block）;
        2. 使用建议
            在频繁切换的情况下， 建议使用hidden;
            在控制条件复杂时，建议使用wx:if、wx:elif、wx:else;

    PS：<block>并不是一个组件，只是一个包裹性的容器，不会渲染到页面上。
```

#### 5. 列表渲染
```javascript{.line-numbers}
    // 使用 wx:key 不用使用 mustache 语法
    <view wx:for="{{ list }}" wx:key="id">
        索引项：{{index}} 
        item项： {{item}}
    </view>

    PS：指定 索引项名称、item项名称
      <view wx:for="{{ list }}" wx:for-index='indexName' wx:for-index='itemName'>
        索引项：{{indexName}} 
        item项： {{itemName}}
      </view>
```
### WXSS
#### 1. rpx 单位
```javascript{.line-numbers}
    1. 现实原理：rpx 把所有设备的屏幕，在宽度上等分为750份；
    2. 设计时，建议使用 iphone 6 作为视觉稿的标准。
```
#### 2. 样式导入
```javascript{.line-numbers}
    @import "样式地址";
```
#### 3. 全局样式与局部样式
```javascript{.line-numbers}
    全局样式：定义在 app.wxss 中的样式为全局样式，作用与每一个页面。
    局部样式：定义在 页面.wxss 中的样式为局部样式，只用与当前页面。

    PS: 1. 当全局样式与局部样式冲突时，根据就近原则，局部样式会覆盖全局样式
        2. 当局部样式的权重大于或等于全局样式的权重时，才会覆盖全局样式
```

### js
#### 1. 事件对像 （event对象）
```javascript{.line-numbers}
 type： 事件类型；
 timeStamp： 页面打开到触发事件所经过的毫秒数；
*target： 触发事件的组件一些属性集合；
 currentTarget： 当前组件的一些属性值集合；
*detail： 额外的信息；
 touches： 触发事件，当前停留在屏幕中触发点信息的数组；
 changeTouches：触发事件，当前变化的触发点信息的数组；
```
**PS：target 和 currentTarget 的区别？？**
    target： 是触发该事件的源头组件 （通过事件冒泡）
    currentTarget：当前事件所绑定的组件

#### 2. 修改 data 中的数据
```javascript{.line-numbers}
    pages({
        data:{
            number:1
        },
        bindTapHandle(){
            // 修改 data 中的数据
            this.setData({
                number: this.data.number
            })
        }
    })
```
#### 3. 编程式导航（页面跳转）
```javascript{.line-numbers}
1. 跳转到 tabBar 页面：
    wx.switchTab({
        url:'地址', // 必填 页面的路径
        success:function(){}, // 成功的回调函数
        fail:function(){}, // 失败的回调函数
        complete:function(){} // 结束的回调函数
    });
2. 跳转到 非tabBar 页面：
    wx.navigateTo({
        url:'地址', // 必填 页面的路径 
        ... // 同上
    });
PS： 传参在 url 中携带参数， onLoad 事件中直接获取
3. 后退导航：
    wx.navigateBlack({
        delta: 1, // 默认为 1，返回的页面数，如果 delta 大于现有页面数，则返回首页
        ... // 同上
    });
```
#### 4. 下拉刷新
```javascript{.line-numbers}
在 JSON 配置文件中，设置 enablePullDownReflect 为 true；
在 JS 文件中，通过 onPullDownReflect() 函数既可监听当前页面的下拉刷新；
停止下拉刷新的效果， 调用 wx.stopPullDownReflect() 可以停止当前页面的下拉刷新的效果；
```
#### 5. 上拉触底（上拉加载）
```javascript{.line-numbers}
在 JSON 配置文件中，设置 onReachBottomDistance 上拉触底事件触发时距页面底部距离；默认为50，单位为：px；
在 JS 文件中，通过 onReachBottom() 函数既可监听当前页面的上拉触底；
节流：
    1. 在 data 中定义 isLoading 节流阀；
    2. 在 getData () 方法中修改 isLoading 节流阀的值；
    3. 在 onReachBottom() 中判断节流阀的值；
```
#### 5. 生命周期
```javascript{.line-numbers}
应用生命周期（app.js）
    onLaunch：小程序初始化完成时，全局出发一次，可以做一些初始化的工作；
    onShow：小程序启动，或从后天进入前台显示时触发；
    onHide：小程序进入后台时触发；
页面生命周期（页面.js）
   *onLoad：监听页面加载，一个页面只调用一次；
    onShow：监听页面显示；
   *onReady：监听页面初次渲染完成，一个页面只调用一次；
    onHide：监听页面隐藏；
    onUnLoad：监听页面卸载。一个页面只调用一次；
```
#### 5. wxs脚本
```javascript{.line-numbers}
内嵌式wxs脚本
    <view>{{m1.toUpper("name")}}</view> // NAME
    <wxs module="m1">
        module.exports.toUpper = function(str){}{
            return str.toUpper();
        }
    </wxs>

外联式wxs脚本
    在 utils 文件夹中，新建 wxs 文件，编写方法。通过 module.exports 抛出方法；
    在 wxml 文件中：
    <view>{{m2.toUpper("name")}}</view> // NAME
    <wxs src="wxs文件地址" module="m2"></wxs> 

PS： 1. wxs 不能调用 JS 中定义的函数；
     2. wxs 不能调用小程序提供的 API；
```
### 4. JSON 页面配置
**页面设置小程序窗口的外观；就近原则**
```javascript{.line-numbers}
navigationBarTitleText：导航栏标题文字内容；
navigationBarBackgroundColor：导航栏北京颜色；如：#000、#fff
navigationBarTextStyle：导航栏标题颜色；仅支持 black/white
backgroundColor：窗口的背景色；如：#000、#fff
backgroundTextStyle：下拉 Loading 的样式；仅支持 dark/light
enablePullDownRefresh： 是否全局开启下拉刷新；*推荐在页面中开启*
onReachBottomDistance: 页面上拉触底事件触发时距页面底部距离；默认为50，单位为：px
```

## 2. 全局配置
### 1.app.json 全局配置文件
#### 1. pages
**记录当前小程序的所有页面的存放路径；**
#### 2. window
**全局设置小程序窗口的外观；**
```javascript{.line-numbers}
navigation:
    navigationBarTitleText：导航栏标题文字内容；
    navigationBarBackgroundColor：导航栏北京颜色；如：#000、#fff
    navigationBarTextStyle：导航栏标题颜色；仅支持 black/white
background:
    backgroundColor：窗口的背景色；如：#000、#fff
    backgroundTextStyle：下拉 Loading 的样式；仅支持 dark/light
页面效果：
    enablePullDownRefresh： 是否全局开启下拉刷新；
    onReachBottomDistance: 页面上拉触底事件触发时距页面底部距离；默认为50，单位为：px
```
#### 3. tabBar
**设置小程序底部的tabBar效果**
```javascript{.line-numbers}
顶部tabBar（没有图标）、底部tabBar：
    list： tab页签的列表，最少两个、最多五个
        pagePath：页面路径，页面必须有在pages中预先定义；
        text：tab 上显示的文字；
        iconPath：未选中时的图片路径；
        backgroundColor： tabBar 的背景颜色；
        iconPath：未选中时的图片路径；
        color：未选中时的文字颜色；
        selectedIconPath: 选中时的图片路径；
        selectedColor： 选中时的文字颜色；
        borderStyle：tabBar 上表框的颜色；
```
#### 4. style
**是否启用新版组件样式**

## 3. 网络请求
#### 1. 网络限制
出于==安全性==方面的考虑，小程序官方==对数据接口的请求==做出了两个显示
```javascript{.line-numbers}
只能请求HTTPS类型的接口；
必须将接口的域名添加到信任列表中；
PS：添加信任列表：小程序管理后台 => 开发 => 开发设置 => 服务器域名 => 修改 request 合法域名
PS：暂时没有合法域名时：开发阶段： 详情 => 本地设置 => 不校验合法域名
```
#### 2. 发起 GET、POST 请求
```javascript{.line-numbers}
    wx.request({
        url: "地址",
        method: "GET、POST",
        data: "Object",
        dataType: "json", //返回的数据格式
        timeout: 6000, //超时时间，单位为毫秒。
        success: function(res){ // 接口调用成功的回调函数
            console.log(res.data);
        },
        fail: function(err){}, // 接口调用失败的回调函数
        complete: function(data){} //接口调用结束的回调函数（调用成功、失败都会执行）
    })
```
### 4. 基础加强
#### 1. 组件与页面的区别
```javascript{.line-numbers}
组件的.json文件中需要声明 component:'true';
组件的.js文件中调用的是 Component() 函数；
组件的
```
#### 2. 引用组件 
```javascript{.line-numbers}
全局引用：
    在 app.json 中引用 与 window、pages 平级
    usingComponents: {
        'my-text': "/component/test/test",
    }
局部引用：
    在 页面.json 中引用
    {
        usingComponents: {
            'my-text': "/component/test/test",
        }
    };

PS：在 页面.wxml 中 使用
    <my-text></my-test>
```