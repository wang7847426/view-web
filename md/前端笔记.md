# 笔记总结
## HTML

## CSS

## Javascript


## Vue、vuex、axios、vue-router
#### Vue
##### 1. vue 渐进式框架
```
    Vue是一套构建用户界面的 渐进式框架，Vue被设计为 自底向上逐级应用，Vue的核心库只关注视图层，不仅容易上手，还可以与第三方的库或已有的项目进行整合。
```
##### 2. 什么是MVVM？
```ruby
    MVVM 是 Model-View-ViewModel 的缩写， M：代表数据模型，定义操作数据的业务逻辑， V：代表视图层，负责渲染数据到页面上， VM：通过双向绑定View和Model进行同步交互，不需要手动操作 DOM 的一种设计思想。
```
##### 3. Vue 的两个核心？
```ruby
    1. 数据驱动： 数据双向绑定，用于保证数据和视图的一致性。
    2. 组件系统： 把页面抽象成对个相对独立的组件，实现代码的重用，提高开发效率和代码的质量，便于代码维护。
```
##### 4. v-if 和 v-show 的区别？
```ruby
    1. 相同性：
        都可以控制 DOM 的 显示和隐藏 
    2. 不同性：
        1. v-if：对 DOM 是删除和创建的过程。 v-show： 只是通过控制css中的display，对 DOM 显示和隐藏。
        2. v-if：值为真的时候才会进行渲染和编译。 v-show：不管值为真假都会进行渲染和编译。
        3. v-if： 切换时消耗大， v-show： 初始渲染的时候消耗大。
        4. v-if： 适用于不频繁切换的业务。 v-show： 适用于频繁切换的业务
```
##### 5. v-if 和 v-for 优先级（vue2的问题， vue3中已经修复）
```ruby
    v-for 的优先级高于 v-if， 这就意味着， 不管 v-if 值为真假都会先循环，后判断。
```
##### 6. ☆ vue中 key 值的作用 ☆
```ruby
    1. key的主要作用是为了更高效的对比虚拟 DOM 中的每个节点是否为相同的节点。
    2. 为了在diff算法执行时更快的找到对应的节点，提高diff速度，更高效的更新虚拟DOM。
```
##### 7. 什么是虚拟DOM？
```ruby
    虚拟DOM就是普通的js对象。是一个用来描述真实dom结构的js对象，因为它不是真实的dom，所以才叫做虚拟dom。
```
##### 8. diff算法

##### 9. Vue 为什么时候异步渲染？
```ruby
    当数据发生变化时就要重新渲染数据，这样性能不高， 为了防止数据一更新就更新组件，所以做了异步渲染。
```

##### 10. ☆ $nextTick? ☆ 
```ruby
nextTick是Vue提供的一个全局API,是在下次DOM更新循环结束之后执行延迟回调，在修改数据之后使用$nextTick，则可以在回调中获取更新后的DOM。
```

##### 11. 异步渲染的原理？
```ruby
    只要侦听到数据变化，Vue将开启1个队列，并缓存在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用；
```
##### 12. Vue 中的 keep-alive
```ruby 
    作用：实现组件缓存;

    生命钩子函数：
        activated: 组件渲染后调用
        deactivated: 组件销毁后调用

    配置属性: 
        1. include: 只有名称匹配的组件会被缓存
        2. exclude: 任何名称匹配的组件都不会被缓存
        3. max: 最多可以缓存多少组件实例
```
##### 13. 什么是Vue的生命周期？
```ruby
    每个Vue实例在创建是都会经过一系列的初始化过程。 
    Vue 的生命周期钩子，就是说在某一个阶段或条件去触发的函数，目的就是为了完成一些动作过着事件。
```
##### 14. Vue的生命钩子有哪些？
```ruby
    beforeCreate:   创建前：data和methods中的数据没有初始化
    created：       创建后：此时 data 和 method 已经初始化完成， DOM 未挂载

    beforeMount：   数据挂载前：模板已获取到，但是数据未挂载到模板上
    mounted：       数据挂载后： 数据已挂载到模板中

    beforeUpdate：  模板更新前：data 改变后，更新数据模板前调用
    updated：       模板更新后：将 data 渲染到数据模板中

    beforeDestroy： 实例被销毁前：此时可以手动销毁一些方法
    destroyed：     销毁后

    keep-alive:
        activated: 组件渲染后调用
        deactivated: 组件销毁后调用
```

##### 15. 什么是scoped？ 其原理是什么？
```ruby
    scoped 是将本组件中的 style 样式，只作于本组件。
    原理：给 HTML 中的 DOM 添加一个不重复 data 属性（形如，data-v-2311c06a）， 来表示他的唯一性。
```
##### 16. Vue组件中name的作用？
```rudy
    1. 当项目使用 keep-alive 时， 可搭配组件的 name 进行缓存过滤。
    2. 组件进行递归时，需要调用自身的 name。
    3. vue 调试工具中显示的 name， 是由 vue 组件中的 name 决定的。
```
##### 17. Vue组件中 data 为什么是函数？
```ruby
    为了组件独立性和复用性，data需要是函数。
    如果data是对象的话，每个组件实例的data 都是同一个引用数据，在使用组件的时候，一个组件改变了，其他组件也跟着改变。
    data要使用函数的形式，每次使用组件的时候创造一个新的地址，这样就不会相互影响了
```
##### 18. vue.$set()
```ruby
    问题： 属性必须在 data 对象上存在, 才是响应式的数据。如果在给对象添加新的属性，新加的属性不是响应式的， 需要通过 Vue.$set();
    使用：
    Array： this.$set(Array, index, newValue);
    Object： this.$set(Object, key, newValue);
```
##### 19. ☆ Vue的响应式原理？☆
```ruby
    当一 Vue 在实例创建是， Vue 都会遍历 data 选项的属性， 用 Object.defineProperty 对这些属性进行监听，当访问和修改属性通知变化。 
    每个组件实例都有相应的 watcher 程序实例，它在组件渲染的过程中会把属性记录作为依赖，当依赖变化时，会通知 watcher重新计算，从而致使它关联的组件得以更新
```
##### 20. Vue 常用的修饰符
```ruby
    1. v-model 修饰符
        1. .lazy: 输入框改变，光标离开 input 框才会更新数据；
        2. .trim: 输入框过滤首尾空格；
        3. .number：自动将用户的输入值转化为数值类型；

    2. 事件修饰符
        1. .once: 绑定的事件只触发一次；
        2. .self: 触发当前元素自身的函数；
        3. .stop: 阻止事件冒泡， 同理： e.stopPropagation()
        4. .prevent: 阻止默认事件， 同理： e.preventDefault();
        5. .native： 触发子组件的的事件

    3. 键盘事件修饰符  @keyup 事件
        1. .enter 回车
        2. .delete 捕获“删除”和“退格”键
        ...
```
##### 21. computed 和 watch
```ruby
    computed: 
        1. 使用和 data 中的数据一样， 
        2. 在调用时不需要加 （）
        3. 必须使用 return 返回
        4. 依赖项的属性没有变化时，从缓存中读取

    watch: 
        1. 函数名称必须和data中的数据名一致
        2. watch 中的函数有两个参数，前者是newVal，后者是oldVal
        3. watch 中的函数是不需要调用的
        4. 只会监听数据的值是否发生改变，而不会去监听数据的地址是否发生改变，要深度监听需要配合deep：true属性使用
        5. immediate:true 页面首次加载的时候做一次监听

    区别： 
        1. 功能： computed是计算属性；watch是监听一个值的变化执行对应的回调
        2. 是否调用缓存：  computed函数所依赖的属性不变的时候会调用缓存， 
                          watch每次监听的值发生变化时候都会调用回调
        3. 是否调用return： computed必须有；watch可以没有
        4. 使用场景： computed当一个属性受多个属性影响的时候；例如购物车商品结算；
                      watch当一条数据影响多条数据的时候，例如搜索框
        5.是否支持异步： computed函数不能有异步；watch可以
```
##### Vue 项目的优化
```ruby
    1.  循环的时候使用正确的key 。
    2.  封装高度复用的模块。
    3.  路由懒加载，首屏加载快。
    4.  keep-alive 缓存不活跃的组件。
    5.  尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher。
    6.  图片放到cdn上 ，icon字体文件。
    7.  组件按需导入 ，需要什么导入什么。
    8.  防抖、节流
    9.  第三方模块按需导入
    10. 在更多的情况下，使用v-if替代v-show
```

## 网络
##### 1. http 状态码；
```javascript{.line-numbers}

    /*
        200:  请求成功
        204： 请求成功，但没有资源返回

        301： 永久重定向
        302： 临时重定向

        400： 请求报文中出现语法错误
        401： 未经授权，禁止访问
        403： 没有权限，禁止访问
        404： 没有找到资源

        500： 服务器内部错误
        503： 服务器超负荷运行
    */ 
```
##### 2. 原生ajax；
```javascript{.line-numbers}
    /* 
        创造请求实例
        new ActiveXObject() IE6 以下
    */ 
    const xml = new XMLHttpRequest();
    /*
        method:  请求方式      如： GET、POST...
        url:     请求的地址
        async：  是否需要跨域   值： true（默认值）， false 
        (如果设置为false,则send方法只有等到服务器返回了结果，才会进行下一步操作)
    */ 
    xml.open("method","url","async");
    /*
        GET 请求：  null
        POST 请求： 字符型的键值对  如： "name=小明"
    */ 
    xml.send(null)
    /*
        使用 onreadystatechange 监听
        当 xml.readyState == 4 && xml.status == 200 时， 
        使用 JSON.parse(xml.responseText)， 接受数据 
    */ 
    xml.onreadystatechange = function(){
        if(xml.readyState == 4 && xml.status == 200){
            console.log(JSON.parse(xml.responseText))
        }
    }
```

