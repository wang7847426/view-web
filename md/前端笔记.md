# 笔记总结
## HTML

## CSS

## Javascript
##### 1. ☆ Js 的数据类型有哪些？☆
```ruby
    基本类型： String， number， Boolean， Null， Undefined，symbol(ES6)，BigInt(ES10);
    复制类型： Array，  Function， Object(包含： Array， Function)；
```
##### 2. ☆ Js 的数据类型检测有哪些方案？☆
```ruby
    1. typeof: 
        优点：能够快速区分基本数据类型;
        缺点：不能将Object、Array和Null区分，都返回object;
        PS: JS中会将二进制前三位为'0'的判断为 object，而 Null 二进制表示全都是0。
        # typeof "test" //string
        # typeof [] //object

    2. instanceof: 
        优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象;
        缺点：Number，Boolean，String基本数据类型不能判断;
        # [] instanceof Array  // true
        # "test" instanceof String // false

    3. Object.prototype.string.call(): 
        优点：精准判断数据类型;
        缺点：写法繁琐不容易记，推荐进行封装后使用;
        # Object.prototype.toString.call('test') === '[object String]' // true
```
##### 3. ☆ 闭包 ☆
```ruby
    闭包： 有权访问另一个函数作用域中的变量的函数；
    用途： 
        1. 模拟块级作用域；
        2. 私有化变量；
        3. 创建模块；
        4. 能够访问函数中私有的变量；
    优点： 延长变量的生命周期；
    缺点： 会导致函数变量一直保存在内存中， 过多的闭包会导致内存的泄露；
    常见的表现形式：  
    /*
        function fn(){
            let a = 1;
            return function(){
                console.log(a);
            }
        }
    */
```
##### 3. ☆ 原型、原型链 ☆
```ruby
    原型：对象中固有的 __proto__ 属性，该属性指向对象的 prototype 原型属性。
    原型链：当访问一个对象的属性时，会先在这个对象本身上找，如果没有会在这个对象的__prort__上找，对象的__proto__ 指向构造函数prototype，还是没有的话，还会在构造函数的__proto__上查找，直到最顶层为null。
```
##### 4. ☆ 继承 ☆
```ruby
    
```
##### 5. ☆ this指向、new关键字 ☆
```ruby
    this指向：
        1. 普通函数调用， this 指向 window；
        2. 对象方法调用， this 指向 这个对象；
        3. 构造函数调用， this 指向 用 new 创建的新对象；
        4. 通过 call、apply、bind 调用， 指定调用函数的 this 指向；

    new 关键字：
        1. 首先创建了一个空对象；
        2. 将对象的原型指向构造函数的 prototype；
        3. 构造函数的 this 指向对象；
        4. 返回新创建的对象
```
##### 6. ☆ 防抖、节流 ☆
```ruby
    
```
##### 7. ☆ 重排(回流)、重绘 ☆
```ruby
    
```
##### 8. ☆ 作用域、作用域链 ☆
```ruby
    作用域：作用域就是变量的可用性的代码范围，就叫做这个变量的作用域。
    作用域分为： 全局作用域、局部作用域、块级作用域；

    作用域链：当你要访问一个变量时，首先会在当前作用域下查找，如果没有查找到，则回去上一级作用域进行查找，直到找到全局作用域，这个查找过程形成的链条叫做作用域链
```
##### 8. ☆ EventLoop ☆
```ruby
    
```
##### 9. ☆ call、apply、bind ☆
```ruby
    call、apply、bind都是改变this指向的方法
    区别：
        call： 参数1：this， 参数2：多个参数使用逗号隔开；
        apply：参数1：this， 参数2：数组的形式；
        bind：不会立即执行，而是返回一个函数，在传参；
```
##### 9. ☆ 事件冒泡、事件委托（捕获） ☆
```ruby
    事件冒泡：对象上绑定事件，如果该对象上有这个事件会触发，如果没有这个事件就会逐级上找；
    事件委托：把原本需要绑定在子元素的响应事件，委托给父元素，让父元素担当事件监听的职务；
            事件委托的原理是DOM元素的事件冒泡。
```
##### 10. 普通函数 和 箭头函数的区别？
```ruby
    箭头函数：
        1. 不能做构造函数，没有prototype原型对象，不能做 new 操作；
        2. 没有this， 在声明时可以捕获其所在上下文的this供自己使用；
        3. 不能通过 apply，call，bind 改变 this 指向；
        4. 没有 arguments 对象，通过使用 ...形参 的方式代替；
        5. 一个参数可省略(), 一行逻辑可省略{} 和 return；
```
##### 11. 什么是跨域问题 ，如何解决跨域问题?
```ruby
    跨域：是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的。  
    同源策略：是浏览器对 JS 实施的安全限制，只要 协议、域名、端口 有任何一个不同，都被当作是不同的域。
    跨域原理：即是通过各种方式，避开浏览器的安全限制。
    方式：
    1. JSONP 的缺点: 使用get请求不安全，携带数据较小；
    2. CORS : 跨域资源共享 服务器设置对CORS的支持原理；
    3. proxy代理: 在开发中使用proxy，在服务器上使用nginx代理；
    4. window.postMessage() 利用h5新特性window.postMessage()
```
##### 12. 双等号的规则
```ruby
    # 1. '对象 == 字符': 会把对象隐式转换为字符串。
    # 2. 'null == Undefined': 为 true ，除了这种情况null/undefined和其他任何值都不会相等；
    # 3. 'NaN == NaN': 为 false ;
    # 4. 'Symbol() == Symbol()': 为 false;
    # /*  除了上面的情况，不同类型间对比的时候都要先转换成数字，再进行比较。*/
```
##### 13. 双等号的规则
```ruby
    
```


## ES6、ES7、ES8、ES9、ES10
#### ES6
##### 1. ES6 新增
```ruby 
    1. 新增symbol类型 表示独一无二的值，用来定义独一无二的对象属性名;
    2. const/let  都是用来声明变量,不可重复声明，具有块级作用域。存在暂时性死区，也就是不存在变量提升。(const一般用于声明常量);
    3. 变量的解构赋值(包含数组、对象、字符串、数字及布尔值,函数参数),剩余运算符(...rest);
    4. 模板字符串(${data});
    5. 扩展运算符(数组、对象);;
    6. 箭头函数;
    7. Set和Map数据结构;
    8. Proxy/Reflect;
    9. Promise;
    10. async函数;
    11. Class;
    12. Module语法(import/export);
```
## Vue、vuex、axios、vue-router
#### Vue
##### 1. vue 渐进式框架
```ruby
    Vue是一套构建用户界面的 渐进式框架，Vue被设计为 自底向上逐级应用，Vue的核心库只关注视图层，不仅容易上手，还可以与第三方的库或已有的项目进行整合。
```
##### 2. 什么是MVVM？
```ruby
    MVVM 是 Model-View-ViewModel 的缩写， M：代表数据模型，定义操作数据的业务逻辑， V：代表视图层，负责渲染数据到页面上， VM：通过双向绑定View和Model进行同步交互，不需要手动操作 DOM 的一种设计思想。
```
##### 3. Vue 的两个核心？
```ruby
    1. 数据驱动： 数据双向绑定，用于保证数据和视图的一致性。
    2. 组件系统： 把页面抽象成对个相对独立的组件，实现代码的重用，提高开发效率和代码的质量，便于代码维护。
```
##### 4. v-if 和 v-show 的区别？
```ruby
    1. 相同性：
        都可以控制 DOM 的 显示和隐藏 
    2. 不同性：
        1. 方式： v-if：对 DOM 是删除和创建的过程。 v-show： 只是通过控制css中的display，对 DOM 显示和隐藏。
        2. 编译： v-if：值为真的时候才会进行渲染和编译。 v-show：不管值为真假都会进行渲染和编译。
        3. 消耗： v-if： 切换时消耗大， v-show： 初始渲染的时候消耗大。
        4. 适用： v-if： 适用于不频繁切换的业务。 v-show： 适用于频繁切换的业务
```
##### 5. v-if 和 v-for 优先级（vue2的问题， vue3中已经修复）
```ruby
    v-for 的优先级高于 v-if， 这就意味着， 不管 v-if 值为真假都会先循环，后判断。
```
##### 6. ☆ vue中 key 值的作用 ☆
```ruby
    1. key的主要作用是为了更高效的对比虚拟 DOM 中的每个节点是否为相同的节点。
    2. 为了在diff算法执行时更快的找到对应的节点，提高diff速度，更高效的更新虚拟DOM。
```
##### 7. 什么是虚拟DOM？
```ruby
    虚拟DOM就是普通的js对象。是一个用来描述真实dom结构的js对象，因为它不是真实的dom，所以才叫做虚拟dom。
```
##### 8. diff算法

##### 9. Vue 为什么时候异步渲染？
```ruby
    当数据发生变化时就要重新渲染数据，这样性能不高， 为了防止数据一更新就更新组件，所以做了异步渲染。
```

##### 10. ☆ $nextTick? ☆ 
```ruby
nextTick是Vue提供的一个全局API,是在下次DOM更新循环结束之后执行延迟回调，在修改数据之后使用$nextTick，则可以在回调中获取更新后的DOM。
```

##### 11. 异步渲染的原理？
```ruby
    只要侦听到数据变化，Vue将开启1个队列，并缓存在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用；
```
##### 12. ☆ Vue 中的 keep-alive ☆ 
```ruby 
    作用：实现组件缓存;

    生命钩子函数：
        activated: 组件渲染后调用
        deactivated: 组件销毁后调用

    配置属性: 
        1. include: 只有名称匹配的组件会被缓存
        2. exclude: 任何名称匹配的组件都不会被缓存
        3. max: 最多可以缓存多少组件实例
```
##### 13. 什么是Vue的生命周期？
```ruby
    每个Vue实例在创建是都会经过一系列的初始化过程。 
    Vue 的生命周期钩子，就是说在某一个阶段或条件去触发的函数，目的就是为了完成一些动作过着事件。
```
##### 14. ☆ Vue的生命钩子有哪些？☆
```ruby
    beforeCreate:   创建前：data和methods中的数据没有初始化
    created：       创建后：此时 data 和 method 已经初始化完成， DOM 未挂载

    beforeMount：   数据挂载前：模板已获取到，但是数据未挂载到模板上
    mounted：       数据挂载后： 数据已挂载到模板中

    beforeUpdate：  模板更新前：data 改变后，更新数据模板前调用
    updated：       模板更新后：将 data 渲染到数据模板中

    beforeDestroy： 实例被销毁前：此时可以手动销毁一些方法
    destroyed：     销毁后

    keep-alive:
        activated: 组件渲染后调用
        deactivated: 组件销毁后调用
```

##### 15. 什么是scoped？ 其原理是什么？
```ruby
    scoped 是将本组件中的 style 样式，只作于本组件。
    原理：给 HTML 中的 DOM 添加一个不重复 data 属性（形如，data-v-2311c06a）， 来表示他的唯一性。
```
##### 16. Vue组件中name的作用？
```rudy
    1. 当项目使用 keep-alive 时， 可搭配组件的 name 进行缓存过滤。
    2. 组件进行递归时，需要调用自身的 name。
    3. vue 调试工具中显示的 name， 是由 vue 组件中的 name 决定的。
```
##### 17. Vue组件中 data 为什么是函数？
```ruby
    为了组件独立性和复用性，data需要是函数。
    如果data是对象的话，每个组件实例的data 都是同一个引用数据，在使用组件的时候，一个组件改变了，其他组件也跟着改变。
    data要使用函数的形式，每次使用组件的时候创造一个新的地址，这样就不会相互影响了
```
##### 18. vue.$set()
```ruby
    问题： 属性必须在 data 对象上存在, 才是响应式的数据。如果在给对象添加新的属性，新加的属性不是响应式的， 需要通过 Vue.$set();
    使用：
    Array： this.$set(Array, index, newValue);
    Object： this.$set(Object, key, newValue);
```
##### 19. ☆ Vue的响应式原理？☆
```ruby
    当一 Vue 在实例创建是， Vue 都会遍历 data 选项的属性， 用 Object.defineProperty 对这些属性进行监听，当访问和修改属性通知变化。 
    每个组件实例都有相应的 watcher 程序实例，它在组件渲染的过程中会把属性记录作为依赖，当依赖变化时，会通知 watcher重新计算，从而致使它关联的组件得以更新
```
##### 20. Vue 常用的修饰符
```ruby
    1. v-model 修饰符
        1. .lazy: 输入框改变，光标离开 input 框才会更新数据；
        2. .trim: 输入框过滤首尾空格；
        3. .number：自动将用户的输入值转化为数值类型；

    2. 事件修饰符
        1. .once: 绑定的事件只触发一次；
        2. .self: 触发当前元素自身的函数；
        3. .stop: 阻止事件冒泡， 同理： e.stopPropagation()
        4. .prevent: 阻止默认事件， 同理： e.preventDefault();
        5. .native： 触发子组件的的事件

    3. 键盘事件修饰符  @keyup 事件
        1. .enter 回车
        2. .delete 捕获“删除”和“退格”键
        ...
```
##### 21. computed 和 watch
```ruby
    computed: 
        1. 使用和 data 中的数据一样， 
        2. 在调用时不需要加 （）
        3. 必须使用 return 返回
        4. 依赖项的属性没有变化时，从缓存中读取

    watch: 
        1. 函数名称必须和data中的数据名一致
        2. watch 中的函数有两个参数，前者是newVal，后者是oldVal
        3. watch 中的函数是不需要调用的
        4. 只会监听数据的值是否发生改变，而不会去监听数据的地址是否发生改变，要深度监听需要配合deep：true属性使用
        5. immediate:true 页面首次加载的时候做一次监听

    区别： 
        1. 功能:  computed是计算属性；
                  watch是监听一个值的变化执行对应的回调；
        2. 是否调用缓存：  computed函数所依赖的属性不变的时候会调用缓存； 
                          watch每次监听的值发生变化时候都会调用回调；
        3. 是否调用return： computed必须有；
                           watch可以没有；
        4. 使用场景： computed当一个属性受多个属性影响的时候；例如购物车商品结算；
                      watch当一条数据影响多条数据的时候，例如搜索框；
        5. 是否支持异步： computed函数不能有异步；
                         watch可以；
```
##### Vue 项目的优化
```ruby
    1.  循环的时候使用正确的key 。
    2.  封装高度复用的模块。
    3.  路由懒加载，首屏加载快。
    4.  keep-alive 缓存不活跃的组件。
    5.  尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher。
    6.  图片放到cdn上 ，icon字体文件。
    7.  组件按需导入 ，需要什么导入什么。
    8.  防抖、节流
    9.  第三方模块按需导入
    10. 在更多的情况下，使用v-if替代v-show
```

#### Vuex
##### 1. 什么是Vuex？
```ruby
    Vuex 是 vue.js 应用程序开发的 状态管理模式 。它采用集中存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化
```
##### 2. Vuex 解决了什么问题？
```ruby 
    中大型单页面应用程序，项目开发中频繁的使用组件传参的方式来同步 data 中的值，管理和维护这些值是非常难的， vuex 是 vue 为了这些被多个组件频繁使用的值提供的一个统一管理的工具。
```
##### 3. Vuex 有哪几种属性？
```ruby 
    state:      存储所有共享的状态信息；
    getters:    计算 state 中的值，在数据展示前进行一些变化处理，具有缓存功能，能够提高运行效率；
    mutations:  更改状态的逻辑，同步操作；理论上修改 state 的唯一路径；
    actions:    提交mutation，可以包含异步操作；
    modules:    将vuex进行分模块；
```
##### 4. mapState, mapGetters, mapActions, mapMutations
```ruby 
    当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。
    mapState： 
    mapGetters：
    mapActions：
    mapMutations：
```
##### 5. store 需要注意的问题？
```ruby
    1. store 存储的状态是响应式的，当组件读取状态时，如果 store 中的状态发生改变，那么相应的组件也会发生改变。
    2. 不能直接改变 store 中的状态。改变 store 的唯一途径是 （commit）mutations，这样使得我们可以方便地跟踪每一个状态的变化。
```
##### 6. mutation 和 action 有什么区别？
```ruby 
    1. 流程顺序：视图触发 -> action 触发 -> mutations 触发 -> state； 

    2. 定位：基于流程顺序，二者扮演不同的角色。
        1. mutation：专注于修改State，理论上是修改State的唯一途径。
        2. action：业务代码、异步请求。

    3. 限制： 定位不同，二者有着不同的限制。
        1. mutation：必须是同步执行。
        2. action：可以是异步，但不能直接修改state；

    4. 调用：
        mutation： 使用 this.$store.commit() 调用；
        action： 使用 this.$store.dispatch() 调用； 
```

#### VueRouter
##### 1. ☆ vue-router 有哪几种钩子函数？(导航守卫)☆
```ruby 
    1. 全局性的守卫：
        1. router.beforeEach :    全局前置守卫，路由跳转前触发，参数 to、from、next
        2. router.beforeResolve : 全局解析守卫，路由跳转前触发， 参数 to、from、next
        3. router.afterEach :     全局后置守卫，路由跳转完成后触发，参数包括to、from，没有 next
    
    2. 路由独享的守卫：
        1. beforeEnter :          路由跳转前触发，如有beforeEach，则在其后触发，参数 to、from、next
    
    3. 组件内的守卫：
        1. beforeRouteEnter :    在组件 beforeCreate 前触发，参数 to、from、next。 (不能使用this，可以使用next中的vm )
        2. beforeRouteUpdate :    (vue-router 2.2 新增) 在当前路由改变，但是依然渲染该组件是调用，参数 to、from、next
        3. beforeRouteLeave :     导航离开该组件的对应路由时被调用，参数 to、from、next
```
##### 2. vue-router 如何响应 路由参数 的变化?
```ruby 
    1. 复用组件时，相对 路由参数的变化 作出响应式， 可以使用 watch 监听 $route 对象；
    2.使用 （vue-router 2.2） 中引入的 beforeRouteUpdate 守卫
```
##### 3. vue-router 路由的两种模式？
```ruby 
    1. hash模式：监听 onhashChange 实现；
    2. histoty模式： 使用 h5的API pushState（）和 replaceState（）和 onpopstate 监听URL变化
    两者的区别：
        1. 原理： 同上
        2. url:  hash模式 url 中带有 '#' 号， histoty模式不带有 '#';
        3. 兼容: hash模式 兼容 IE8， histoty 模式 兼容 IE10
        4. 跳转: hash模式 只能修改'#'后面的内容，history模式 只要是同源的就可以
```
##### 4. VueRouter传递参数 query 和 params 的区别？
```ruby 
   1. 传参： query 传参会在url 中显示; params 传参不会在url中显示;
   2. 刷新： query 刷新后 数据不会丢失; params 刷新后数据会丢失;
   3. 引入： query传参要用path、name来引入; params传参要用name来引入（如果是path， 过去的参数为undefined）;

   ps： params传参 不想刷新后数据丢失，需要在 router 中在该路径后面配置'/:id'
```
##### 5. router 和 route 的区别？
```ruby 
    $router: 是 VueRouter 的实例，相当于一个全局的路由器对象，作用是进行路由跳转的；
    $route: 是跳转路由对象，每一个路由都会有一个route对象，是一个局部的对象，可以获取对应的值；
```
##### 4. vue-router 传递参数的几种方式
```ruby 

```
#### Axios

## 网络
##### 1. http 状态码；
```javascript{.line-numbers}

    /*
        200:  请求成功
        204： 请求成功，但没有资源返回

        301： 永久重定向
        302： 临时重定向

        400： 请求报文中出现语法错误
        401： 未经授权，禁止访问
        403： 没有权限，禁止访问
        404： 没有找到资源

        500： 服务器内部错误
        503： 服务器超负荷运行
    */ 
```
##### 2. 原生ajax；
```javascript{.line-numbers}
    /* 
        创造请求实例
        new ActiveXObject() IE6 以下
    */ 
    const xml = new XMLHttpRequest();
    /*
        method:  请求方式      如： GET、POST...
        url:     请求的地址
        async：  是否需要跨域   值： true（默认值）， false 
        (如果设置为false,则send方法只有等到服务器返回了结果，才会进行下一步操作)
    */ 
    xml.open("method","url","async");
    /*
        GET 请求：  null
        POST 请求： 字符型的键值对  如： "name=小明"
    */ 
    xml.send(null)
    /*
        使用 onreadystatechange 监听
        当 xml.readyState == 4 && xml.status == 200 时， 
        使用 JSON.parse(xml.responseText)， 接受数据 
    */ 
    xml.onreadystatechange = function(){
        if(xml.readyState == 4 && xml.status == 200){
            console.log(JSON.parse(xml.responseText))
        }
    }
```

